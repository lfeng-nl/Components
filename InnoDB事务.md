# InnoDB事务

## 1.事务简介

> 数据库事务拥有四个特性, 称为ACID:
>
> A: 原子性(Atomic), 事务作为一个整体被执行, 要么全部执行, 要么不执行.
>
> C:一致性(Consistent), 事务执行前后, 数据库中的数据应满足完整性约束.
>
> I:隔离性(Isolation), 多个事务并发执行, 一个事务不应该影响其他事务的执行.
>
> D: 持久性(Duration), 已被提交的事务对数据库的修改应永久保存在数据库中.

## 2.隔离性 Isolation

### 1.事务并发的问题

- **脏读**: 读到其他事务未提交的数据;
- **不可重读**: 在同一个事务中, 使用相同的查询语句, 同一资源前后读取值不一致;
- **幻读**: 同一个事务中多次读取一个范围内的记录, 数量不一致(读取到的结果集不一样, 不可重读是单一资源值不一致, 幻读是因为插入或删除数据导致结果集不一致).
- **丢失更新**: 两个事务同时修改资源, 导致其中一个的更新被覆盖.

### 2.隔离级别

> 为平衡数据并发存在的上述问题和性能, 引入了隔离级别:
> **READ-UNCOMMITTED 读未提交**: 所有并发问题可能碰到, 但性能最好.
> **READ-COMMITTED 读提交**: 存在幻读, 不可重读.
> **REPEATABLE-READ 可重复读**:  MySQL的默认隔离级别(MySQL上存在丢失更新问题)
> **SERIALIZABLE 串行化**: 无并发问题, 效率最低.

- **`READ-COMMITTED` 读提交**

  - 一个事务可以读取另一个已提交的事务.
  - 同一事务的多次读取结果可能不同(其他事务提交了修改), 称为**不可重复读问题**.

- **`REPEATABLE-READ` 可重复读**

  - MySQL 的默认事务隔离级别.
  - 同一个事务中多次读取相同的数据返回的结果是一样的.
  - 可能出现**幻读**(其他事务的提交读取不到).

- **`SERIALIZABLE` 串行化**

  - 如果有事务未提交, 则对其相关表的修改阻塞.
  - 如果有事务修改未提交, 则对其相关表的读取阻塞.
  - 代价搞, 性能低.

### 3.隔离级别的实现

#### 1.锁

> 通过锁的类型(S/X), 颗粒度, 持有锁的时间进行合理组合, 就可以实现不同的隔离级别.

- 基本分类
  - 共享锁: S锁, 也称为读锁.
  - 排他锁: X锁, 也称为写锁.

- 根据锁的颗粒度,  可以分为: 表锁, 行锁.

- 存在的问题: 读写频繁时, 造成阻塞. 影响并发效率.

#### 2.MySQL隔离级别的实现MVCC

> MVCC: Multi-Version Concurrent Control, 多版本并发控制.

