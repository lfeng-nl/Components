# InnoDB事务

## 1.事务简介

> 数据库事务拥有四个特性, 称为ACID:
>
> A: 原子性(Atomic), 事务作为一个整体被执行, 要么全部执行, 要么不执行.
>
> C:一致性(Consistent), 事务执行前后, 数据库中的数据应满足完整性约束.
>
> I:隔离性(Isolation), 多个事务并发执行, 一个事务不应该影响其他事务的执行.
>
> D: 持久性(Duration), 已被提交的事务对数据库的修改应永久保存在数据库中.

## 2.隔离性 Isolation

### 1.事务并发的问题

- **脏读**: 读到其他事务未提交的数据;
- **不可重读**: 在同一个事务中, 使用相同的查询语句, 同一资源前后读取值不一致;
- **幻读**: 同一个事务中多次读取一个范围内的记录, 数量不一致(读取到的结果集不一样, 不可重读是单一资源值不一致, 幻读是因为插入或删除数据导致结果集不一致).
- **丢失更新**: 两个事务同时修改资源, 导致其中一个的更新被覆盖.

### 2.隔离级别

> 为平衡数据并发存在的上述问题和性能, 引入了隔离级别:
> **READ-UNCOMMITTED 读未提交**: 所有并发问题可能碰到, 但性能最好.
> **READ-COMMITTED 读提交**: 存在幻读, 不可重读.
> **REPEATABLE-READ 可重复读**:  MySQL的默认隔离级别(MySQL上存在丢失更新问题)
> **SERIALIZABLE 串行化**: 无并发问题, 效率最低.

- **`READ-UNCOMMITTED` 读未提交**
  - 可以读到其他事务为提交的数据. 也称为**脏读**.
  - 数据库的并发性最好, 但是数据的准确性最低.

- **`READ-COMMITTED` 读提交**

  - 一个事务可以读取另一个已提交的事务.
  - 同一事务的多次读取结果可能不同(其他事务提交了修改), 称为**不可重复读问题**.

- **`REPEATABLE-READ` 可重复读**

  - MySQL 的默认事务隔离级别.
  - 同一个事务中多次读取相同的数据返回的结果是一样的.
  - 可能出现**幻读**(其他事务的提交读取不到).

- **`SERIALIZABLE` 串行化**

  - 如果有事务未提交, 则对其相关表的修改阻塞.
  - 如果有事务修改未提交, 则对其相关表的读取阻塞.
  - 代价搞, 性能低.

### 3.隔离级别的实现

#### 1.锁

> 通过锁的类型(S/X), 颗粒度, 持有锁的时间进行合理组合, 就可以实现不同的隔离级别.

- 基本分类
  - 共享锁: S锁, 也称为读锁.
  - 排他锁: X锁, 也称为写锁.

- 根据锁的颗粒度, 可以分为: 表锁, 行锁.
  - 表锁: 由MySQL服务器实现.
  - 行锁: 由数据库引擎实现.

- 记录锁:
  - `UPDATE tb1 SET name='xx' WHERE id=5;`
  - 记录加在**索引上(使用的索引和聚簇索引)**.
  - 如果没有建立索引, MySQL会进行全表扫描, 查询符合条件的数据, 这时, 会给**表的所有数据行加记录锁**.

- 间隙索引:
  - 在RR级别使用, RC级别不会使用间隙锁.
  - 加在两个索引之间, 或者加在第一个索引之前/最后一个索引之后的间隙. 也称范围锁.
  - 防止其他事务在这个范围内插入或修改记录. 保证两次读取这个范围内的记录不变(解决幻读现象).

- Next-Key Locks(记录锁和间隙锁的组合):
  - 也是避免幻读, 使用在RR隔离级别上.
  - 主要产生在二级索引且非唯一的索引上, 避免因为插入相同索引值的行, 导致幻读.
  - 在**某条记录**以及**这条记录前面间隙**上的锁.
  - 所以需要将前一个索引值到当前索引值上加`Next-Key Locks`, 当前索引和下一个索引值间加间隙锁.

- 意向锁:
  > 为了方便对表加锁(对表加锁时, 需要判定是否和行级锁)
  - 意向共享锁(IS): 事务**打算给数据行加行共享锁**; 给数据行加共享锁前必须先获取该表达的IS锁.
  - 意向排他锁(IX): 事务**打算给数据行加行排他锁**; 给数据行加排他锁前必须先取得该表的IX锁.

- 乐观锁和悲观锁
  - 并不是具体的锁类型, 而是一种加锁的思想.
  - 一般的并发事务管理, 仅需要设置好适合的隔离级别, 就能解决大多的并发问题, 仅使用正常的SQL即可.
  - 对于当前隔离级别无法解决的问题,(例如RR级别的更新丢失). 需要额外手段.
  - 悲观锁:
    - 每次拿数据都假设别人会来修改数据, 所以每次拿数据都会加锁. 来避免冲突.
    - 依靠数据库锁机制.
  - 乐观锁:
    - 认为拿数据的时候别人不会修改, 所以不会上锁, 但是更新的时候会判定版本号来决定是否修改成功.
    - 依靠程序逻辑.

- 存在的问题: 读写频繁时, 造成阻塞. 影响并发效率.

#### 2.加锁的SQL语句

- `SELECT ...;`: 读快照, 不加锁.
- `SELECT ... LOCK IN SHARE MODE;`: 读当前, 加S锁.
- `SELECT ... FOR UPDATE`: 读当前, 加X锁.
- DML(数据操作, 增删改), 加X锁.
- DDL(数据定义, 表的修改), 加表级锁, 隐式提交, 不可回滚.
- `LOCK TABLES tbl_name READ|WRITE, tbl_name lock_type;`: 对表加锁.

#### 3.MVCC

> MVCC: Multi-Version Concurrent Control, 多版本并发控制. 提高并发性, 实现读写并行.
> 实现依赖: undo log, read view

- **注意, 事务中的加锁读和普通读**

- 一致性非锁定读取(**快照读**):
  - 使用普通的`select`语句.
  - 使用MVCC在某个时间点查询显示数据库的快照.
  - 在RR级别: 发出普通的查询时, 为事务提供了一个时间点, 根据时间点来查询数据库(查时间点前的数据快照).
  - 在RC级别: 普通查询, 读取记录的最新版本(已提交的最新版本).

- 加锁读(**当前读**)
  - 读取的不再是快照版本, 而是数据库最新版本, 并会对数据加锁.
  - `SELECT ... LOCK IN SHARE MODE;`: 读取并加S锁.
  - `SELECT ... FOR UPDATE;`: 读取并加X锁.

- 事务中的`INSERT,UPDATE,DELETE`会加X锁.
  - RC级别: 只加记录锁.
  - RR级别: 加间隙锁, 解决幻读问题.

- undo log: 回滚日志, 记录事务操作前的数据库内容.
  - undo log中的行就是MVCC中的多版本.

#### 4.隔离级别查看和设置

- 查看: `SHOW variables like "tx_isolation";`
- 设置: `SET tx_isolation="READ-COMMITTED";`
