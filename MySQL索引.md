# MySQL 索引

## 1.B 树

- 又称为平衡多路查找树.
  1. 每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树
  2. B 树每个中间节点有 k-1 个关键字(参与比较的数据)和 k 个子树, (`k=ceil(m/2)-1`, ceil(): 朝正无穷方向取整).
  3. B 树的所有**叶子节点都在同一层**

![B树](./image/b-tree.jpg)

- B+树
  - 非叶子节点不保存关键字记录的指针, 只进行数据索引(**增大了非叶子节点保存关键字的能力**).
  - 叶子节点保存了父节点的所有关键字记录的指针, 数据必须到叶子节点才能获取.
  - 叶子节点有序.
  - 非叶子节点的子节点数=关键字数.

![B+数](./image/b+tree.jpg)

- B+树的优点:
  - 内部节点没有数据(占用空间小), 可以将内部几点集中放置, 减少磁盘 I/O(局部原理, 缓存).
  - 所有数据都查询到叶子节点, 查询效率稳定.
  - 仅遍历叶子节点即可遍历整棵树, 提高遍历效率.

## 2.索引概述

> 索引: 存储引擎**对索引的数据**维护一种数据结构, 达到快速查找的目的. 索引能够显著提高查询效率, 但是创建和维护索引需要消耗时间;
>
> 索引具有以下优点: 1.减少了服务器需要扫描的数据量, 2.帮助服务器避免排序和创建临时表, 3.将随机 I/O 变为顺序 I/O
>
> MySQL 中, 索引是在存储引擎层实现的. 不同的存储引擎, 索引的支持和实现各不相同.

### 1.索引类型

- **B-Tree**索引: 一般所说的索引基本都是 B-Tree 索引.

  - 使用 B-Tree(B+Tree)数据结构来存储数据;
  - 适用于: 全键值(=), 键值范围(>, <), 前缀查找(最左前缀).
  - 索引还可以用于查询排序操作.
  - 索引前缀: 只用指定字段的指定前缀长度(**最长 1000 个字节**)作为索引, `CREATE TABLE xxx( xxx, KEY index_name (索引列(10)))`,;
  - 多列索引: 也称为复合索引, 最多包含 16 列;
    - `INDEX name (last_name, first_name)`;
    - 最左前缀: 例如有个三列索引`(col1, col2, col3)`, 则可索引`(col1), (col1, col2), (col1, col2, col3)`

- 哈希索引: 基于哈希表, 只有精确匹配的查询才有效; 只有`Memory`引擎支持;

  - 适用于`=`或`!=`运算符()精确匹配)
  - 只有整个键可用于搜索(哈希值不同);

- 空间数据索引 (R-Tree): MyISAM 表支持, 可以用作地理数据存储.

- 全文索引`FULLTEXT KEY`: 查找文本中的关键字.

### 2.聚簇索引

> 索引和全部内容保存在同一个结构, 通过索引查询能直接查询到数据内容.

- InnoDB 聚簇索引的叶子节点存储行记录，因此，InnoDB 必须要有，且只有一个聚集索引;

  - 如果表定义了 `PK`，则 `PK` 就是聚集索引；
  - 如果表没有定义 PK，则第一个 not NULL unique 列是聚集索引；
  - 否则，InnoDB 会创建一个隐藏的 row-id 作为聚集索引；

- 聚簇索引查询能直接定位到数据. 例如主键查询, 能直接查询到数据行.

- 非聚簇索引: 叶子节点保存了**主键值**，要定位记录还要再查一遍聚簇索引.

  - 需要 回表查询(先通过索引, 定位到主键, 然后再通过主键索引, 查询到数据).
  - 说人话: 需要使用两个索引, 才定位到数据.

### 3.联合索引

> 在一棵树上, 按照多个大小比较结果, 为多个列建立索引`KEY index_name (col1, col2, col3)`.

- 当查询条件精确匹配左边**连续**一个或多个列时, 会使用联合索引. 例如`(col1), (col1, col2), (col1, col2, col3)`
- 如果想使用联合索引中尽可能多的类, 搜索条件中的各个列必须是联合索引中从最左边连续的列.

## 2.B-Tree 索引

### 1.B树

- 又称为平衡多路查找树.
  1. 每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树
  2. B 树每个中间节点有 k-1 个关键字(参与比较的数据)和 k 个子树, (`k=ceil(m/2)-1`, ceil(): 朝正无穷方向取整).
  3. B 树的所有**叶子节点都在同一层**

![B树](./image/b-tree.jpg)

- B+树
  - 非叶子节点不保存关键字记录的指针, 只进行数据索引(**增大了非叶子节点保存关键字的能力**).
  - 叶子节点保存了父节点的所有关键字记录的指针, 数据必须到叶子节点才能获取.
  - 叶子节点有序.
  - 非叶子节点的子节点数=关键字数.

![B+数](./image/b+tree.jpg)

- B+树的优点:
  - 内部节点没有数据(占用空间小), 可以将内部几点集中放置, 减少磁盘 I/O(局部原理, 缓存).
  - 所有数据都查询到叶子节点, 查询效率稳定.
  - 仅遍历叶子节点即可遍历整棵树, 提高遍历效率.

## 3.索引添加和使用策略

### 1.查询时正确使用

- **索引不能是表达式的一部分, 也不能是函数的参数**: 如`...WHERE actor_id + 1=5;`
- 查询的列表中只包含索引列, 这样, 当前索引的叶子节点就相当于有了查询数据, 不必再回表(到聚簇索引中查询). 称为 覆盖索引.
  - `SELECT name FROM tb1 where name > 'xx';`

### 2.正确创建索引

- 前缀索引: 对于**很长的字符列**, 需要选择合适的前缀, 节约索引空间, 提高效率.`KEY index_name(col1(xx))`
- 后缀索引: 原生不支持, 可以将字符串倒叙存储, 建立前缀索引实现.
- 索引列的类型尽量小, 提高比较速度.
- InnoDB 的数据实际上时存储在**聚簇索引**上的, 在中间插入值时, 会导致页面裂变, 增加性能损耗.
  - 避免主键的中间插入.
  - **主键设置自增, 让存储引擎自动生成主键**.
