# Redis基础架构

## 单线程的Redis?

Redis单线程主要是指**Redis的网络IO和键值对读写是由一个线程来完成的**.Redis的其他功能, 如持久化, 异步删除, 集群同步等功能是由额外的线程执行.

- 为什么使用单线程?
    - 避免竞争, 减少了加锁, 降低了系统设计的复杂度.
- 单线程的Redis为什么可以很快?
    - 大部分的操作都是在内存上完成的.
    - 采用合理的数据结构(跳表, 哈希表).
    - **多路复用机制**, 能并发处理大量的客户端请求.

## 如何避免阻塞?

- 复杂度较高的查询(`O(n)`)级别.
    - 集合的全量查询和聚合操作.
    - bigkey的删除(大量的零碎的空间释放).
    - `FLUSHDB`; 
- 磁盘I/O
- **异步子线程机制**: 主线程启动后, 创建多个子线程, 主线程通过**链表形式的任务队列**与子线程交互. 将对应的操作封装成任务, 放入对应的任务队列中.
    - ![异步子线程](./image/threads.jpg)

## 并发访问

- 加锁: 会降低并发性能.
- 原子操作:
    - 多个操作在Redis中实现成一个操作(单命令)
    - Lua脚本.

## ACID ? 

- 最早是通过`MULTI, EXEC, DISCARD, WATCH`来实现简单事务. 可以在单个步骤中执行一组命令.
- 不支持回滚.
- Redis事务可以执行的所有操作, 也可以使用脚本执行, 推荐使用脚本.

## 持久化机制

### AOF (Append Only File)

> "后写日志", Redis先执行命令, 把数据写入内存, 然后才记录日志.

- AOF写回策略:
    - **Always**: 同步, 每个写命令执行, 立马同步将日志写回磁盘.
    - **Everysec**: 每秒写回, 先写内存缓冲区, 每秒写入磁盘(flush).
    - **No**: 操作系统控制写回.
- AOF重写:
    - 将多个写操作合并, 减小日志文件.
    - 重写过程由后台进程`bgrewriteaof`完成. 避免阻塞主线程.
    - **两处日志**: 主线程会写AOF缓冲和AOF重写缓冲, 避免重写日志丢失最新数据, 或者异常宕机, AOF日志丢失.
    - ![aof重写](./image/aof.jpg)

### RDB快照

> Redis DataBase 记录某一时刻的内存数据.

- 生成快照:
    - `save`: 主线程中执行, 会导致阻塞.
    - `bgsave`: 创建一个子进程, 利用写时复制, 避免阻塞主线程.
    - 

